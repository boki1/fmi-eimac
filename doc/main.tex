\documentclass[numbering=fraction]{beamer}
\usetheme[progressbar=frametitle]{metropolis}

\usepackage[bulgarian]{babel}
\usepackage[utf8]{inputenc}
\usepackage[style=alphabetic,backend=biber]{biblatex}
\usepackage{blindtext}
\usepackage{tikz}
\usepackage{progressbar}
\usepackage{amsmath,amssymb,amsfonts,amsthm}
\usepackage{caption}
\captionsetup{labelformat=simple, font={tiny,sf}}
\usepackage{fontawesome}
\uselanguage{Bulgarian}
\languagepath{Bulgarian}
\providetranslation[to=Bulgarian]{Corollary}{Следствие}

\addbibresource{bibliography.bib}
\graphicspath{{./}}

\usepackage[table]{xcolor}
\definecolor{lightgrey}{HTML}{969696}
\definecolor{lightergrey}{HTML}{a5a5a5}

\renewcommand{\emph}[1]{\textit{\textcolor{salmon}{#1}}}

\RequirePackage{fancyvrb}
\RecustomVerbatimEnvironment{Verbatim}{Verbatim}{fontfamily=cmtt,framesep=3mm,fontsize=\small,numbers=left,xleftmargin=7mm,numberblanklines=false,frame=lines,rulecolor=\color{lightpurple}}
\DefineVerbatimEnvironment{Code}{Verbatim}{fontfamily=cmtt,framesep=3mm,fontsize=\small,numbers=left,xleftmargin=7mm,numberblanklines=false,frame=lines,rulecolor=\color{salmon}, tabsize=2}
\DefineVerbatimEnvironment{Mono}{Verbatim}{fontfamily=cmtt,framesep=3mm,fontsize=\tiny,numbers=left,xleftmargin=7mm,numberblanklines=false,frame=none,rulecolor=\color{darkgray}, tabsize=2}

\title{Кодиране}
\titlegraphic{\vspace{4cm}\flushright\includegraphics[width=2cm,height=1.25cm]{fmi-logo.png}}
\author[Author]{Кристиян Стоименов}
\institute{Факултет по математика и информатика,\\\textbf{Ефективна реализация\\ на математически алгоритми\\ и концепции}}
\date{\today{}}

\usepackage{mdframed}
\usepackage{amsthm}

\newtheorem{dfn}{Дефиниция}[section]
\surroundwithmdframed[
linewidth=1pt,
linecolor=salmon,
backgroundcolor=lightergrey!10,
roundcorner=15pt,
skipabove=\topsep,
skipbelow=\topsep
]{dfn}
\newtheorem{thm}{Теорема}[section]
\surroundwithmdframed[
linewidth=1pt,
linecolor=redish,
backgroundcolor=lightergrey!10,
roundcorner=15pt,
skipabove=\topsep,
skipbelow=\topsep
]{thm}

\begin{document}
\include{template}

\begin{frame}[plain]{}
\maketitle
\end{frame}

\begin{frame}
	\begin{dfn}\bigskip
		Код на Рид-Соломон наричаме ...
	\end{dfn}
\end{frame}

\begin{frame}
	\begin{figure}
		\centering \label{fig:mascot-no-frame-cartoonish}
		\includegraphics[width=.7\textwidth]{mascot-no-frame-cartoonish.png}
	\end{figure}
\end{frame}

\section{Основни понятия}
\begin{frame}[allowframebreaks]
\par \emph{Шумозащитно кодиране} наричаме набор от математически средства и алгоритми, чрез които грешки, възникнали при предаване на информация по канал между два агента, биват разпознати и поправени.
\begin{figure}[allowframebreaks]
	\centering \label{fig:setup}
	\includegraphics[width=.6\textwidth]{setup.png}
	\caption{Опростен модел на предаване на информация през комуникационен канал.}
\end{figure}
\framebreak
\begin{figure}
	\centering \label{fig:voy2}
	\includegraphics[width=.9\textwidth]{voyager2.png}
	\caption{Voyager 2 е безпилотна космическа сонда на НАСА, изстреляна през 1977 г., която изследва външните планети на Слънчевата система. Единственият апарат, посетил Уран и Нептун. Снимката е взема от \autocite{voyager2}.}
\end{figure}
\framebreak
\begin{figure}
	\centering \label{fig:raid6}
	\includegraphics[width=.7\textwidth]{raid6.png}
	\caption{RAID-6 е схема за нареждане на масив от дискове с цел максимално бързодействие и едновременно с това издръжливост при грешка. \autocite{raid6}}
\end{figure}
\framebreak
\begin{itemize}
	\item Приложенията на шумозащитното кодиране са много. Някои други от тях включват CD \autocite{cd} и QR кодовете \autocite{qr}.
	\item Основния фактор, допускащ ефективността на шумозащитното кодиране е следната теоремата за шумния канал (Шанън, 1948) \autocite{mackay_itila}. В общо линии тя гласи, че за произволен шумен канал, съобщения могат да се предават без загуба на информация, стига преносът да не надхвърля \textit{капацитета} - максималната пропускателна способност, на канала.
\end{itemize}
\framebreak
\par Какво представлява шумът?
\begin{figure}[c]
	\centering \label{fig:noise}
	\includegraphics[height=.35\textheight]{noise-p.png}
	\hspace*{3em}
	\includegraphics[height=.45\textheight]{noisy-channel.jpg}
	\caption{Двоичен симетричен канал.}
\end{figure}
\framebreak
\par \emph{Шумозащитен код}, или за по-кратко само \emph{код}, наричаме систематичен подход за съпоставяне между съобщение и кодова дума. Това съпоставяне се разглежда в две посоки:
\begin{itemize}
    \item Посоката \fcolorbox{salmon}{white}{,,съобщение $\mapsto$ кодова дума''} се нарича \emph{кодиране}. \textit{Кодирането изменя съобщението, добавяйки \emph{проверочни символи} \footnote{на англ. redundancy}, такива че входното съобщение да бъде възстановено в случай на промяна по време на предаване.}
    \item Обратната, \fcolorbox{salmon}{white}{,,кодова дума $\mapsto$ съобщение''}, се нарича \emph{декодиране} и именно тя е същината на един шумозащитен код. \textit{Декодирането използва въведените от кодирането проверочни символи, за да поправи възникнали грешки от предаването, \textbf{ако свойствата на шумозащитния код позволяват това}.}
\end{itemize}
\framebreak
\begin{figure}[allowframebreaks]
	\centering \label{fig:channel}
	\includegraphics[width=.95\textwidth]{channel.png}
	\caption{Опростен модел на предаване на информация през комуникационен канал, използвайки шумозащитен код.}
\end{figure}
\end{frame}

\begin{frame}{}
	\egmarker
	\par {\Large \textbf{Код с повторение}}
	\par Нека разгледаме един елементарен пример за шумозащитен код, за да илюстрираме по-ясно модела на предаване на информация през комуникационен канал.
	\par Следва да фиксираме няколко основни параметъра на нашия код - дължина на съобщението и брой проверочни символа. От тях получаваме директно и максималния брой грешки, които шумозащитния код е способен да възстанови.
	\par Нека за нашите цели съобщението се състои от 16 бита, а броят на проверочните символи е 32 бита. Така кодовата дума става за дължина 48 бита.
\end{frame}
\begin{frame}[fragile]
	\egmarker
	\par Използваме следния алгоритъм за кодиране. Ефектът от него е, че всеки бит от съобщението се предава точно по три пъти, т.е. повтаряме съобщението три пъти. Оттам и името на този код.
	\begin{Code}
u64 encode(u16 msg)
{
	u64 codeword=msg|msg<<16|msg<<32;
	return codeword;
}
	\end{Code}
\end{frame}
\begin{frame}[fragile]
	\egmarker
	\vspace*{-2em}
	\par Декодирането също става очевидно - за всеки от битовете в получената кодова дума избираме стойност за съобщението, съответстваща на модата от стойностите на трите копия.
	\vspace*{-1em}
	\begin{Code}
u16 decode(u64 codeword)
{
	u16 msg=0;
	for (int i=0; i<16; ++i
	{
		int l1=1<<i, l2=1<<(16+i), l3=1<<(32+i);
		int b1=!!(codeword&l1), b2=!!(codeword&l2),
		  b3=!!(codeword&l3);
		msg |= b1+b2+b3>>1<<i;
	}
	return msg;
}
	\end{Code}
\end{frame}

\begin{frame}
	\par Разграничаваме \emph{откриване} от \emph{поправяне} на грешка. В първия случай имаме единствено информация, че полученото съобщение се различава от изпратеното. Във втория случай знаем не само това, ами и кои точно битове са били промени.
	\par Друг вариант за грешка е обаче някои от битовете да бъдат \textit{пропуснати}, а не обърнати. Също така възникват и други особености при бройни системи, които не са двоичната - в такива случаи не е достатъчно да знаем къде е възникнала грешката, тъй като има повече от една възможна друга стойност.
\end{frame}
\begin{frame}
	\egmarker
	\par Прост пример за това е т.нар. \emph{проверка по четност}. Нейната идея е следната. Ако имаме съобщение, съставено от например 7 двоични символа, то проверка по четност реализираме, добавяйки символ с такава стойност, че броя на всички единици сред съобщението да бъде четен. Очевидно в случая можем да забележим единствено нечетен брой грешки, а да поправим, не можем да нито една от тях.
	\begin{figure}
		\centering \label{fig:parity-check}
		\includegraphics[width=.6\textwidth]{parity-check.png}
		\caption{Прост пример за проверка по четност.}
	\end{figure}
\end{frame}

\section{Код на Хеминг}
\begin{frame}
	\par Преди да се насочим към общата теория на линейните блокови кодове, нека разгледаме как е функционирал първият шумозащитен код - малко по-нетривиален пример от кода с повторение. Той е известен като код на Хеминг, който е негов изобретател през 40-те години в Bell Labs.
	\par Основната идея, на която се основава той е следната: ако поставим
		\textit{достатъчно} на брой проверки по четност и при това те да бъдат на \textit{точните} места, получаваме удобен и	лесен начин за откриване на \textit{единствена грешка}.
	\par Ще разгледаме как се случва това при съобщения от 11 бита, които се поставят в 15-битови кодови думи. Подходът се запазва аналогично при блок с произволна дължина $2^m$.
\end{frame}
\begin{frame}
	\begin{center}
		\begin{tabular}{ |c|c|c|c| }
			\hline \cellcolor{orange!25}0 & \cellcolor{yellow!25}1 & \cellcolor{yellow!25}2 & \cellcolor{green!25}3 \\
			\hline \cellcolor{yellow!25}4 & \cellcolor{green!25}5  & \cellcolor{green!25}6	& \cellcolor{green!25}7 \\
			\hline \cellcolor{yellow!25}8 & \cellcolor{green!25}9  & \cellcolor{green!25}10 & \cellcolor{green!25}11 \\
			\hline \cellcolor{green!25}12 & \cellcolor{green!25}13 & \cellcolor{green!25}14 & \cellcolor{green!25}15 \\
			\hline
		\end{tabular}
	\end{center}
	
	\par Използваме този нагласен ,,формат'', попълвайки съобщението, което
	искаме да изпратим (11 бита) в зелените клетки. В жълтите ще поставим проверочните
	битовете, а оражевото временно ще игнорираме.
	\par Стойностите, сега намиращи се в клетките на шаблона, отговарят на ,,индекса'', който ще
	използваме за съответната клетка (т.е. аналогично можем да си представим и
	последователно разположение, вместо таблично).
\end{frame}
\begin{frame}[allowframebreaks]
	\par Нека попълним клетките със съобщението \texttt{10011001101}:
	\begin{center}
		\begin{tabular}{ |c|c|c|c| }
			\hline \cellcolor{orange!25} & \cellcolor{yellow!25} & \cellcolor{yellow!25} & \cellcolor{green!25}1 \\
			\hline \cellcolor{yellow!25} & \cellcolor{green!25}0 & \cellcolor{green!25}0 & \cellcolor{green!25}1 \\
			\hline \cellcolor{yellow!25} & \cellcolor{green!25}1 & \cellcolor{green!25}0 & \cellcolor{green!25}0 \\
			\hline \cellcolor{green!25}1 & \cellcolor{green!25}1 & \cellcolor{green!25}0 & \cellcolor{green!25}1 \\
			\hline
		\end{tabular}
	\end{center}
	
	\par Жълтите клетки - проверките по четност - попълваме със стойностите, съответстващи на
	следните четири подгрупи от клетки:
	
	\fboxsep=0pt
	\noindent
	\begin{minipage}[t]{0.23\linewidth}
		\begin{tabular}{ |c|c|c|c| }
			\hline \cellcolor{white!25} & \cellcolor{blue!25} & \cellcolor{white!25} & \cellcolor{blue!25} \\
			\hline \cellcolor{white!25} & \cellcolor{blue!25} & \cellcolor{white!25} & \cellcolor{blue!25} \\
			\hline \cellcolor{white!25} & \cellcolor{blue!25} & \cellcolor{white!25} & \cellcolor{blue!25} \\
			\hline \cellcolor{white!25} & \cellcolor{blue!25} & \cellcolor{white!25} & \cellcolor{blue!25} \\
			\hline
		\end{tabular}
	\end{minipage}
	\hfill%
	\begin{minipage}[t]{0.23\linewidth}
		\begin{tabular}{ |c|c|c|c| }
			\hline \cellcolor{white!25} & \cellcolor{white!25} & \cellcolor{blue!25} & \cellcolor{blue!25} \\
			\hline \cellcolor{white!25} & \cellcolor{white!25} & \cellcolor{blue!25} & \cellcolor{blue!25} \\
			\hline \cellcolor{white!25} & \cellcolor{white!25} & \cellcolor{blue!25} & \cellcolor{blue!25} \\
			\hline \cellcolor{white!25} & \cellcolor{white!25} & \cellcolor{blue!25} & \cellcolor{blue!25} \\
			\hline
		\end{tabular}
	\end{minipage}
	\hfill%
	\begin{minipage}[t]{0.23\linewidth}
		\begin{tabular}{ |c|c|c|c| }
			\hline \cellcolor{white!25} & \cellcolor{white!25} & \cellcolor{white!25} & \cellcolor{white!25} \\
			\hline \cellcolor{blue!25} & \cellcolor{blue!25} & \cellcolor{blue!25} & \cellcolor{blue!25} \\
			\hline \cellcolor{white!25} & \cellcolor{white!25} & \cellcolor{white!25} & \cellcolor{white!25} \\
			\hline \cellcolor{blue!25} & \cellcolor{blue!25} & \cellcolor{blue!25} & \cellcolor{blue!25} \\
			\hline
		\end{tabular}
	\end{minipage}
	\hfill%
	\begin{minipage}[t]{0.23\linewidth}
		\begin{tabular}{ |c|c|c|c| }
			\hline \cellcolor{white!25} & \cellcolor{white!25} & \cellcolor{white!25} & \cellcolor{white!25} \\
			\hline \cellcolor{white!25} & \cellcolor{white!25} & \cellcolor{white!25} & \cellcolor{white!25} \\
			\hline \cellcolor{blue!25} & \cellcolor{blue!25} & \cellcolor{blue!25} & \cellcolor{blue!25} \\
			\hline \cellcolor{blue!25} & \cellcolor{blue!25} & \cellcolor{blue!25} & \cellcolor{blue!25} \\
			\hline
		\end{tabular}
	\end{minipage}
	\par Можем да забележим, че първите две подгрупи успяват да намерят колоната, в която е
	възникнала грешка, докато вторите две - редичката.
	\par Нека попълним и жълтите клетки с проверките по четност за примерното съобщение: \\
	\vspace{.5cm}
	\fboxsep=0pt
	\noindent
	\begin{minipage}[t]{0.23\linewidth}
		\begin{tabular}{ |c|c|c|c| }
			\hline \cellcolor{white!25}  & \cellcolor{blue!25}  & \cellcolor{white!25}  & \cellcolor{blue!25}1 \\
			\hline \cellcolor{white!25}  & \cellcolor{blue!25}0 & \cellcolor{white!25}0 & \cellcolor{blue!25}1 \\
			\hline \cellcolor{white!25}  & \cellcolor{blue!25}1 & \cellcolor{white!25}0 & \cellcolor{blue!25}0 \\
			\hline \cellcolor{white!25}1 & \cellcolor{blue!25}1 & \cellcolor{white!25}0 & \cellcolor{blue!25}1 \\
			\hline
		\end{tabular}
	\end{minipage}
	\hfill%
	\begin{minipage}[t]{0.23\linewidth}
		\begin{tabular}{ |c|c|c|c| }
			\hline \cellcolor{white!25}  & \cellcolor{white!25}  & \cellcolor{blue!25}  & \cellcolor{blue!25}1 \\
			\hline \cellcolor{white!25}  & \cellcolor{white!25}0 & \cellcolor{blue!25}0 & \cellcolor{blue!25}1 \\
			\hline \cellcolor{white!25}  & \cellcolor{white!25}1 & \cellcolor{blue!25}0 & \cellcolor{blue!25}0 \\
			\hline \cellcolor{white!25}1 & \cellcolor{white!25}1 & \cellcolor{blue!25}0 & \cellcolor{blue!25}1 \\
			\hline
		\end{tabular}
	\end{minipage}
	\hfill
	\begin{minipage}[t]{0.23\linewidth}
		\begin{tabular}{ |c|c|c|c| }
			\hline \cellcolor{white!25}  & \cellcolor{white!25}  & \cellcolor{white!25}  & \cellcolor{white!25}1 \\
			\hline \cellcolor{blue!25}  & \cellcolor{blue!25}0 & \cellcolor{blue!25}0 & \cellcolor{blue!25}1 \\
			\hline \cellcolor{white!25}  & \cellcolor{white!25}1 & \cellcolor{white!25}0 & \cellcolor{white!25}0 \\
			\hline \cellcolor{blue!25}1 & \cellcolor{blue!25}1 & \cellcolor{blue!25}0 & \cellcolor{blue!25}1 \\
			\hline
		\end{tabular}
	\end{minipage}
	\hfill
	\begin{minipage}[t]{0.23\linewidth}
		\begin{tabular}{ |c|c|c|c| }
			\hline \cellcolor{white!25} & \cellcolor{white!25}  & \cellcolor{white!25}  & \cellcolor{white!25}1 \\
			\hline \cellcolor{white!25} & \cellcolor{white!25}0 & \cellcolor{white!25}0 & \cellcolor{white!25}1 \\
			\hline \cellcolor{blue!25}  & \cellcolor{blue!25}1 & \cellcolor{blue!25}0 & \cellcolor{blue!25}0 \\
			\hline \cellcolor{blue!25}1 & \cellcolor{blue!25}1 & \cellcolor{blue!25}0 & \cellcolor{blue!25}1 \\
			\hline
		\end{tabular}
	\end{minipage}
	\par Както може би забелязвате, интересното за позициите на \textit{жълтите клетки}
	(и причината за именно този избор), е това, че всеки проверочен бит попада в
	точно една от подгрупите.
	\break
	\par Друго важно наблюдение ни показва по какъв начин избрахме точно това да са
	подгрупите - ако разгледаме отново шаблона за попълване с въведени индексите
	на всяка от клетките ще забележим, че например първата подгрупа включва тези
	и само тези клетки, чиито индески завършват на 1.
	\begin{center}
		\begin{tabular}{ |c|c|c|c| }
			\hline \cellcolor{white!25}0000  & \cellcolor{blue!25}0001  & \cellcolor{white!25}0010  & \cellcolor{blue!25}0011 \\
			\hline \cellcolor{white!25}0100  & \cellcolor{blue!25}0101  & \cellcolor{white!25}0110  & \cellcolor{blue!25}0111 \\
			\hline \cellcolor{white!25}1000  & \cellcolor{blue!25}1001  & \cellcolor{white!25}1010  & \cellcolor{blue!25}1011 \\
			\hline \cellcolor{white!25}1100  & \cellcolor{blue!25}1011  & \cellcolor{white!25}1110  & \cellcolor{blue!25}1111 \\
			\hline
		\end{tabular}
	\end{center}
	\par Аналогично следващите подгрупи ни дават тези, включващи \texttt{..1.},
	\texttt{.1..} и \texttt{1...}.
	\framebreak
	\par Така до момента можем да попълним всички без един от битовете в онзи
	16-битов пакет:
	\begin{center}
		\begin{tabular}{ |c|c|c|c| }
			\hline \cellcolor{orange!25} & \cellcolor{yellow!25}1 & \cellcolor{yellow!25}1 & \cellcolor{green!25}1 \\
			\hline \cellcolor{yellow!25}0 & \cellcolor{green!25}0 & \cellcolor{green!25}0 & \cellcolor{green!25}1 \\
			\hline \cellcolor{yellow!25}0 & \cellcolor{green!25}1 & \cellcolor{green!25}0 & \cellcolor{green!25}0 \\
			\hline \cellcolor{green!25}1 & \cellcolor{green!25}1 & \cellcolor{green!25}0 & \cellcolor{green!25}1 \\
			\hline
		\end{tabular}
	\end{center}
	\par Нека го игнорираме още малко и да разгледаме как точно поправяме възникнала
	грешка.
	\par \textbf{Бележка:} До момента можем да кажем, че сме се запознали с (почти
		цялата) процедура по кодиране и следва да декодираме.
	
	\framebreak
	\par Допускаме, че бит с индекс 6 е бил обърнат.
	\begin{center}
		\begin{tabular}{ |c|c|c|c| }
			\hline \cellcolor{orange!25} & \cellcolor{yellow!25}1 & \cellcolor{yellow!25}1 & \cellcolor{green!25}1 \\
			\hline \cellcolor{yellow!25}0 & \cellcolor{green!25}0 &
			\cellcolor{green!25}\textcolor{red}{1} & \cellcolor{green!25}1 \\
			\hline \cellcolor{yellow!25}0 & \cellcolor{green!25}1 & \cellcolor{green!25}0 & \cellcolor{green!25}0 \\
			\hline \cellcolor{green!25}1 & \cellcolor{green!25}1 & \cellcolor{green!25}0 & \cellcolor{green!25}1 \\
			\hline
		\end{tabular}
	\end{center}
	
	\par Извършваме проверките по четност, използвайки подгрупите, определящи
	стойностите на проверочните битове една по една и записваме резултата от всеки от тях.\\
	\fboxsep=0pt
	\noindent
	\begin{minipage}[t]{0.23\linewidth}
		\begin{tabular}{ |c|c|c|c| }
			\hline \cellcolor{white!25}  & \cellcolor{blue!25}1 & \cellcolor{white!25}1 & \cellcolor{blue!25}1 \\
			\hline \cellcolor{white!25}0 & \cellcolor{blue!25}0 & \cellcolor{white!25}\textcolor{red}{1} & \cellcolor{blue!25}1 \\
			\hline \cellcolor{white!25}0 & \cellcolor{blue!25}1 & \cellcolor{white!25}0 & \cellcolor{blue!25}0 \\
			\hline \cellcolor{white!25}1 & \cellcolor{blue!25}1 & \cellcolor{white!25}0 & \cellcolor{blue!25}1 \\
			\hline
		\end{tabular}
		\begin{center} \par 0 \end{center}
	\end{minipage}
	\hfill%
	\begin{minipage}[t]{0.23\linewidth}
		\begin{tabular}{ |c|c|c|c| }
			\hline \cellcolor{white!25}  & \cellcolor{white!25}1 & \cellcolor{blue!25}1 & \cellcolor{blue!25}1 \\
			\hline \cellcolor{white!25}0 & \cellcolor{white!25}0 & \cellcolor{blue!25}\textcolor{red}{1} & \cellcolor{blue!25}1 \\
			\hline \cellcolor{white!25}0 & \cellcolor{white!25}1 & \cellcolor{blue!25}0 & \cellcolor{blue!25}0 \\
			\hline \cellcolor{white!25}1 & \cellcolor{white!25}1 & \cellcolor{blue!25}0 & \cellcolor{blue!25}1 \\
			\hline
		\end{tabular}
		\begin{center} \par 1 \end{center}
	\end{minipage}
	\hfill
	\begin{minipage}[t]{0.23\linewidth}
		\begin{tabular}{ |c|c|c|c| }
			\hline \cellcolor{white!25}  & \cellcolor{white!25}1 & \cellcolor{white!25}1 & \cellcolor{white!25}1 \\
			\hline \cellcolor{blue!25}0 & \cellcolor{blue!25}0 & \cellcolor{blue!25}\textcolor{red}{1} & \cellcolor{blue!25}1 \\
			\hline \cellcolor{white!25}0 & \cellcolor{white!25}1 & \cellcolor{white!25}0 & \cellcolor{white!25}0 \\
			\hline \cellcolor{blue!25}1 & \cellcolor{blue!25}1 & \cellcolor{blue!25}0 & \cellcolor{blue!25}1 \\
			\hline
		\end{tabular}
		\begin{center} \par 1 \end{center}
	\end{minipage}
	\hfill
	\begin{minipage}[t]{0.23\linewidth}
		\begin{tabular}{ |c|c|c|c| }
			\hline \cellcolor{white!25} & \cellcolor{white!25}1 & \cellcolor{white!25}1 & \cellcolor{white!25}1 \\
			\hline \cellcolor{white!25}0 & \cellcolor{white!25}0 & \cellcolor{white!25}\textcolor{red}{1} & \cellcolor{white!25}1 \\
			\hline \cellcolor{blue!25}0 & \cellcolor{blue!25}1 & \cellcolor{blue!25}0 & \cellcolor{blue!25}0 \\
			\hline \cellcolor{blue!25}1 & \cellcolor{blue!25}1 & \cellcolor{blue!25}0 & \cellcolor{blue!25}1 \\
			\hline
		\end{tabular}
		\begin{center} \par 0 \end{center}
	\end{minipage}
	\framebreak
	\par \textbf{Магия!} Получихме именно 6.
	\par Основната причина този декодиращ алгоритъм да работи (и при това така
	елегантно) се дължи на организацията на ,,подгрупите'' от битове, чрез които
	ефективно извършваме двоично търсене - най-десният бит грешен ли е? а този
	вляво? а този вляво? \dots а най-левият бит грешен ли е?
	\framebreak
	\par Последното парче от пъзела е бит с индекс 0 - каква функция изпълнява той?
	Всъщност той не е полезен за алгоритъма, който разгледахме до момента. Тъй като
	обаче обичайно 15-битов блок от данни е твърде необичайно (не е степен на 2), последният
	бит се използва за проверка по четност на останалите 15 бита. По този начин
	получаваме механизъм за поправяне на единствена грешка, но улавяне на две
	възникнали. Тази добавка на още един бит за четност обичайно се нарича разширен
	код на Хеминг.
\end{frame}

\begin{frame}
	\par Възникват няколко естествени въпроса.
	\begin{itemize}
		\item Има ли подход, по който да кодираме информация така, че да можем да възстановим дори повече от една грешка?
		\item Има ли как да постигнем това придържайки се към прости алгоритми за кодиране и декодиране? Целта ти е тези операции да бъдат \textit{бързи}.
	\end{itemize}
	\par Настоящият проект не претендира да отговаря изчерпателно на тези два въпроса, а само да приближи изготвилия труда, както и слушателите на това представяне, към \textit{истината} \smiley.
\end{frame}

\section{Линейни блокови кодове}
\begin{frame}
	\par Нека разгледаме какво точно представлява един шумозащитен код.
	\par Оттук насетне считаме, че източник съставя съобщения използвайки \textit{символи} от крайно поле $\mathbb{F}$ с мощност $q$. Тъй като полетата, които ни интересуват са крайни, обичайно ги бележим с $GF(q)$.
	\begin{dfn}
		\bigskip
		\par $(n,k)$ \emph{блоков код} $\mathcal{C}$ над азбука от $q$ символа наричаме множество от $q^k$ вектора, всеки от които има дължина $n$. Тези вектори наричаме кодови думи.
		\par На всеки блоков код съответства енкодер, който съпоставя на \textit{съобщението} $m\in\mathbb{F}^k$ съответна кодова дума $c\in\mathcal{C}$.
	\end{dfn}
\end{frame}
\begin{frame}
	\par Често кодовете, които ни интересуват имат следното свойство.
	\begin{dfn}
		\bigskip
		\par Нека блоковия $(n,k)$ код $\mathcal{C}$ над $GF(q)$ образува линейно подпространство на линейното пространство от наредените $n$-торки $\mathbb{F}^n_q$. Тогава за $\mathcal{C}$ казваме, че е \emph{линеен} блоков код.
	\end{dfn}
	\par Използвайки аксиомите на линейно пространство, получаваме начин за ,,конструиране'' на нови кодови думи. Например, ако $c_1, c_2\in\mathcal{C}$, то $c_1+c_2\in\mathcal{C}$.
\end{frame}
\begin{frame}[allowframebreaks]
	\par Третата основна характеристика на блоковите кодове освен дължината на съобщението и дължината на кодовата дума е неговото минимално разстояние. Именно то определя максималният брой грешки, които кодът може да поправи. За целта ни е необходима следната метрика.
	\begin{dfn}
		\bigskip
		\emph{Разстояние на Хеминг} между две кодови думи $a,b\in\mathcal{C}$, където $\mathcal{C}$ e $(n,k)$ код, наричаме \[
			d(a,b) := \left| \left\{\, i \mid a_i \ne b_i \,\right\} \right|
		\]
	\end{dfn}
	\framebreak
	\begin{dfn}
		\bigskip
		\par \emph{Минимално разстояние} на $\mathcal{C}$ наричаме \[
			d(\mathcal{C}) := \min \{\, d(a,b) \mid a,b \in \mathcal{C},\ a \ne b \,\}
		\]
		\vspace*{-2em}
		\par Стойността \[
			t = \left\lfloor \frac{d-1}{2} \right\rfloor
		\]
		наричаме \emph{радиус на опаковка} и съвпада с максималния брой грешки, които могат да бъдат поправени от кода $\mathcal{C}$.
		\par $(n,k)$ код $\mathcal{C}$, при който $d:=d(\mathcal{C})$, бележим като $(n,k,d)$ код.
	\end{dfn}
\end{frame}
\begin{frame}
	\begin{figure}
		\centering \label{fig:sphere-pack}
		\includegraphics[width=.6\textwidth]{sphere-pack.png}
		\caption{Абстрактно представяне на кодови думи заедно с радиус на опаковка.}
	\end{figure}
\end{frame}
\begin{frame}
	\par Оттук насетне ще разглеждаме линейни блокови кодове. Нека $\mathcal{C}$ e $(n,k,d)$ линеен код. От линейната алгебра ни е известно понятието \textit{базис} и знаем също така, че произволен елемент $c\in\mathcal{C}$ може да се представи (по единствен начин) като \textit{линейна комбинация} на базисните вектори. Нека $g_0, \cdots, g_{k-1}$ образува базис на $\mathcal{C}$. Тогава за произволна кодова дума $c\in\mathcal{C}$ е вярно, че \[
	c = \sum_{i=0}^{k-1} m_i g_i
	\]
\end{frame}
\begin{frame}
	\par Или, записвайки вектори $g_i$ като редове на една матрица $G$ \[
	G =	\begin{bmatrix}
		g_0 \\
		g_1 \\
		\vdots \\
		g_{k-1}
	\end{bmatrix}
	\]
	и съобщението като вектор-ред \[
	m = [ m_0 \cdots m_{k-1} ]
	\]
	кодовата дума, съответстваща на съобщението $m$ получаваме като \[
	c = mG
	\]
	\par Матрицата $G$ се нарича \emph{пораждаща} за кода $\mathcal{C}$. Чрез нея директно получаваме алгоритъм за кодиране - а именно чрез умножение.
\end{frame}
\begin{frame}
	\egmarker
	\par Нека за илюстрация разгледаме един от първите използвани шумозащитни кодове - $(7,4)$ кодът на Хеминг. Чрез него 4-битови съобщения се кодират в 7-битови кодови думи, използвайки 3 проверочни бита. Една негова пораждаща матрица е \[
		G =
		\begin{bmatrix}
			1 & 1 & 0 & 1 & 0 & 0 & 0 \\
			0 & 1 & 1 & 0 & 1 & 0 & 0 \\
			0 & 0 & 1 & 1 & 0 & 1 & 0 \\
			0 & 0 & 0 & 1 & 1 & 0 & 1
		\end{bmatrix}
	\]
	\par Тогава съобщението $m = [1 0 0 1]$ кодираме по следния начин \[
		c = mG = [ 1 1 0 0 1 0 1 ]
	\]
\end{frame}
\begin{frame}
	\par Използвайки метриката \textit{разстояние по Хеминг} схемата на декодиране се нарича \emph{метод на максималното правдоподобие}. Имаме следната
	\begin{thm}\bigskip
		За двоичен симетричен канал с вероятност за грешка $p<\frac{1}{2}$ декодирането по метода на максималното правдоподобие е еквивалентно на декодиране до най-близката кодова дума.
	\end{thm}
	\par Сега ще разгледаме как работи това декодиране чрез таблица на Слепян.
\end{frame}
\begin{frame}
	\par Преди да посочим алгоритъма, ни необходима е следната
	\begin{dfn}\bigskip
		\par Нека $\mathcal{C}$ е двоичен $(n,k)$ код. \emph{Съседен клас} на кода $\mathcal{C}$, определен от вектора $y$ наричаме множеството \[
			y + \mathcal{C} := \{\, y + c \mid c \in \mathcal{C} \,\}
		\]
		\par \emph{Лидер} на съседен клас $y + \mathcal{C}$ наричаме елемента \[
		\hat{c} := \min_{c \in y+\mathcal{C}} \operatorname{wt}(c)		
		\]
		където ${wt}(c)$ е \emph{теглото} на кодовата дума $c$, т.е. броят не ненулевите битове из двоичната кодова дума.
	\end{dfn}
\end{frame}

\begin{frame}
	\par Нека разгледаме сега алгоритъма за декодиране на получена дума.
	\par Нека източникът е изпратил кодовата дума $c$, а поради шума на канала се е добавила някаква грешка $e$. До декодера достига (в общия случай) некодова дума $y=c+e$. Тогава е вярно, че \[
		y+c = (c+e)+c = (c+c)+e = e
	\]
	тъй като в $GF(2)$ събирането съвпада с операцията \textsc{изключващо или}, а то има свойството $\forall a \; \bigl( a \oplus a = 0 \bigr)$.
	\par Оттук сме уверени, че получената дума $y$ и грешката $e$ принадлежат на един и същи съседен клас, както и, че всички възможно грешки при получена дума $y$ са именно думите от този съседен клас.
\end{frame}

\begin{frame}[allowframebreaks]
	\par Тогава това, което се изисква от декодер, използващ метода на максималното правдоподобие, е да намерим най-близката кодова дума $\tilde{c}$. Естествено е също така да допуснем по острието на Окам, че грешката е от минимално тегло - т.е. това е лидерът на съседния клас $y+\mathcal{C}$.
	\par Най-елементарният подход е да изброим всички съседни класове и да си харесваме. Използваме т.нар. стандартна таблица или \emph{таблица на Слепян}.
	\framebreak
	\par Щом кодовите думи има дължина $k$, то всички такива са общо $2^k$. Полагаме $M:=2^k$. Имаме, че кодът $\mathcal{C} = \{c_1,\cdots,c_M\}$. Конструираме таблицата от $M$ стълба и $2^{n-k}$ реда. В първия ред разполагаме кодовите думи от $\mathcal{C}$, започвайки от $\mathcal{O}$. На всеки от следващите $t$ реда, където $t$ е радиусът на опаковка, разполагаме съседен клас $e + \mathcal{C}={e,e+c_1,\cdots,e+c_{M-1}}$, сортирайки съседните класове според теглата на техните лидери. \textit{Защо само следващите $t$ реда?} Ами, защото онези съседни класове ,,под чертата'' не можем да декодираме еднозначно.
	\framebreak
	\par След като вече имаме генерирана таблица на Слепян, алгоритъмът е следният. Получена дума $y$, не непременно кодова, търсим из таблицата на Слепян, и интерпретираме лидера на съответния ред като възникналата грешка.
	\par Тогава възстановената кодова дума се получава като сума от получената дума и грешката.
\end{frame}

\begin{frame}
\begin{table}[h]
	\centering
	\small
	\begin{tabular}{|c c c c c|l|}
		\hline
		$0$ & $c_1$ & $c_2$ & $\dots \dots$ & $c_{M-1}$ &  \\ \cline{1-5}
		$e_1$ & $e_1 + c_1$ & $e_1 + c_2$ & $\dots \dots$ & $e_1 + c_{M-1}$ & съседни класове \\
		\multicolumn{5}{|c|}{$\dots \dots \dots \dots \dots \dots \dots \dots \dots \dots \dots \dots \dots \dots$} & с лидери с тегло \\
		$e_s$ & $e_s + c_1$ & $e_s + c_2$ & $\dots \dots$ & $e_s + c_{M-1}$ & \multicolumn{1}{c|}{$\le t$} \\ \hline
		$e_{s+1}$ & $e_{s+1} + c_1$ & $e_{s+1} + c_2$ & $\dots \dots$ & $e_{s+1} + c_{M-1}$ & съседни класове \\
		\multicolumn{5}{|c|}{$\dots \dots \dots \dots \dots \dots \dots \dots \dots \dots \dots \dots \dots \dots$} & с лидери с тегло \\
		$e_N$ & $e_N + c_1$ & $e_N + c_2$ & $\dots \dots$ & $e_N + c_{M-1}$ & \multicolumn{1}{c|}{$> t$} \\ \hline
	\end{tabular}
	\caption{Стандартна таблица на Слепян}
\end{table}
\end{frame}

\begin{frame}[fragile]
	\demomarker
	\par Нека разгледаме една примерна стандартна таблица на Слепян.
	\begin{Mono}
Number of cosets: 8
Coset size: 16
0       1       2       3       4       5       6       7       8       9      10      11      12      13      14      15
------------------------------------------------------------------------------------------------------------------------------------------
0000000 |  0000000 0010110 0011001 0100101 0101010 1110000 1001100 1000011 0111100 0110011 0001111 1010101 1011010 1100110 1101001 1111111
0000001 |  0000001 0010111 0011000 0100100 0101011 1110001 1001101 1000010 0111101 0110010 0001110 1010100 1011011 1100111 1101000 1111110
0000010 |  0000010 0010100 0011011 0100111 0101000 1110010 1001110 1000001 0111110 0110001 0001101 1010111 1011000 1100100 1101011 1111101
0000011 |  0000011 0010101 0011010 0100110 0101001 1110011 1001111 1000000 0111111 0110000 0001100 1010110 1011001 1100101 1101010 1111100
0000100 |  0000100 0010010 0011101 0100001 0101110 1110100 1001000 1000111 0111000 0110111 0001011 1010001 1011110 1100010 1101101 1111011
0000101 |  0000101 0010011 0011100 0100000 0101111 1110101 1001001 1000110 0111001 0110110 0001010 1010000 1011111 1100011 1101100 1111010
0000110 |  0000110 0010000 0011111 0100011 0101100 1110110 1001010 1000101 0111010 0110101 0001001 1010011 1011100 1100000 1101111 1111001
0000111 |  0000111 0010001 0011110 0100010 0101101 1110111 1001011 1000100 0111011 0110100 0001000 1010010 1011101 1100001 1101110 1111000
	\end{Mono}
\end{frame}

\begin{frame}
	\par Както забелязвате, този метод е крайно непрактичен по множество причини. Съществуват подходи за неговото опростяване на алгоритъма за общия случай на линеен код. Нека разгледаме метода на \textit{декодиране чрез синдроми}.
\end{frame}
\begin{frame}
	\begin{dfn}\bigskip
		\emph{Проверочно съотношение} за двоичен код $\mathcal{C}$ се нарича такова хомогенно линейно уравнение \[
			p: a_1x_1 + \cdots a_nx_n=0
		\]
		за което е изпълнено, че всяка кодова дума $c\in\mathcal{C}$ е решение на $p$, т.е. \[
			 a_1c_1 + \cdots a_nc_n=0
		\]
	\end{dfn}
\end{frame}
\begin{frame}
	\begin{dfn}\bigskip
		Двоичен код, определен от проверочните съотношения $p_1, \cdots, p_n$, наричаме множеството от всички двоични думи с дължина $n$, които са решения на системата уравнения \[
		\left\{
		\begin{aligned}
			p_1 &: \quad a_{1,1}x_1 + \dots + a_{1,n}x_n = 0 \\
			p_2 &: \quad a_{2,1}x_1 + \dots + a_{2,n}x_n = 0 \\
			&\ \ \vdots \\
			p_s &: \quad a_{s,1}x_1 + \dots + a_{s,n}x_n = 0
		\end{aligned}
		\right.
		\]
		Коефициентите на тази система образуват \emph{проверочна матрица} за кода $\mathcal{C}$, съставен от това множеството от двоични думи с дължина $n$.
	\end{dfn}
\end{frame}
\begin{frame}
	\par Проверочна матрица ни интересува, поради следното си основно свойство.
	\begin{thm}\bigskip
		Ако имаме линеен код $\mathcal{C}$, който се определя от проверочната си матрица $H$, то е вярно, че \[
			c \in \mathcal{C} \iff cH^T=0
		\]
	\end{thm}
	\par Следващият резултат пък излага как да получим проверочна матрица, ако разполагаме с пораждащата такава.
	\begin{thm}\bigskip
		Проверочна матрица на линеен $(n,k)$ код има вида $H=(A|E_{n-k})$ \textsc{тстк} съществува пораждаща матрица $G$ на този код от вида $G=(E_k|A^T)$.
	\end{thm}
\end{frame}
\begin{frame}
	\par Използвайки проверочната матрица можем да получим по-ефикасен алгоритъм за декодиране. Той се основава на следната
	\begin{dfn}\bigskip
		Нека имаме линеен $(n,k)$ код $\mathcal{C}$. Ако $x$ e произволен $n$-мерен вектор, \emph{синдром} на $x$ наричаме $(n-k)$-мерния вектор \[
			s^T=Hx^T
		\]
	\end{dfn}
\end{frame}
\begin{frame}
	\par За синдромите можем да направим следните две тривиални наблюдения.
	\begin{itemize}
		\item Произволен вектор $c\in\mathbb{F}^n$ e принадлежи на кода \textsc{тстк} $c$ има нулев синдром.
		\item Два вектора $a,b\in\mathbb{F}^n$ имат равни синдроми \textsc{тстк} принадлежат на един и същи съседен клас на кода. Доказателството на това твърдения е следното: \[
			Hx^T=Hy^T \iff H(x+y)^T \iff x+y\in\mathcal{C} \iff x\in y+\mathcal{C}
		\]
	\end{itemize}
\end{frame}
\begin{frame}
	\par Основавайки се на последното свойство, можем да модифицираме таблицата на Слепян така, че тя да съдържа единствено две колони. В първата имаме лидерите на съседните класове на кода, а във втората - техните синдроми.
	\par Алгоритъмът за декодиране на произволен линеен код става следния. За получен вектор $y$ пресмятаме синдрома $s^T=Hy^T$ и намираме реда от таблицата, чиято дясна колона е полученият синдром. Лидерът, намиращ се в лявата колона е възникналата грешка.
\end{frame}

\begin{frame}[fragile]
	\demomarker
	\par Нека разгледаме една примерна таблица със синдроми.
	\begin{Mono}
Syndrome | Leader
------------------
000      | 0000000
001      | 0000001
010      | 0000010
011      | 1000000
100      | 0000100
101      | 0100000
110      | 0010000
111      | 0001000
	\end{Mono}
\end{frame}

\section{Циклични кодове}
\begin{frame}[allowframebreaks]
	\begin{dfn}\bigskip
		Нека имаме вектор $b=[b_0, b_1, \cdots, b_{n-1}]$. \emph{Циклично преместване} на $b$ наричаме вектор $b'$, получен като координатите са разместени така, че втората е записана на първо място, третата на втората и т.н.. Първата е записана на последно място. \[
			b' := [b_1, b_2, \cdots b_0]
		\]
	\end{dfn}
	\framebreak
	\begin{dfn}\bigskip
		Линеен блоков код, който заедно с всяка своя кодова дума $c=[c_0, \cdots, c_{n-1}]$ съдържа още и неговото циклично завъртане $c'=[c_1, \cdots, c_0]$, се нарича \emph{цикличен код}.
	\end{dfn}
	\par При работа с циклични кодове е удачно да имаме дефинирани не само операциите от линейното пространство, но още и \textit{умножение на вектори} над полето $GF(q)$.
	\par Поради тази причина се използва следното съответствие \[
		c=[c_0, \cdots, c_{n-1}] \mapsto c(x)=c_0+c_1x+\cdots+c_{n-1}x^{n-1}
	\]
	и още по-конкретно израза \[
		c(\omega)=c_0+c_1\omega+\cdots+c_{n-1}\omega^{n-1}\qquad\text{където}\; \omega^n=1
	\]
\end{frame}
\begin{frame}
	\begin{figure}
		\centering \label{fig:roots-of-unity}
		\rootsofunity{7}
	
		\caption{Решения на уравнението $x=\sqrt[7]{1}$. \textbf{Забележка:} Решенията са точно елементите на цикличната група $\mathbb{C}_7$.}
	\end{figure}
\end{frame}
\begin{frame}[allowframebreaks]
	\par Цикличните кодове, понеже са линейни, имат своя пораждаща матрица. Но освен нея те имат и пораждащ полином -
	\begin{dfn}\bigskip
		\par \emph{Пораждащ полином} $g(x)$ на цикличен код $\mathcal{C}$ се нарича полиномът от най-ниска степен, съответстващ на ненулева кодова дума $g\in\mathcal{C}$. Бележим $\mathcal{C}=\langle g \rangle$.
	\end{dfn}
	\framebreak
	\par Той е особен, поради свойствата, следващи от следната
	\begin{thm}\bigskip
		Ако имаме цикличен код $\mathcal{C}=\langle g \rangle$, то:
		\begin{itemize}
			\item полиномът $g(x)$ дели $x^n-1$ без остатък;
			\item вектор $c$ е кодова дума \textsc{тстк} $g(x)$ дели $c(x)$;
			\item ако $deg(g)=r$, то $\mathcal{C}$ e $(n,n-r)$ код, а пораждаща матрица $G$ изглежда така - \[
			G = \begin{pmatrix}
				g_0 & g_1 & \dots & g_r & 0 & 0 & \dots & 0 \\
				0 & g_0 & g_1 & \dots & g_r & 0 & \dots & 0 \\
				\hdots & \hdots & \hdots & \hdots & \hdots & \hdots & \hdots & \hdots \\
				0 & 0 & \dots & 0 & g_0 & g_1 & \dots & g_r
			\end{pmatrix}
			\]
		\end{itemize}
	\end{thm}
\end{frame}
\begin{frame}
	\egmarker
	\par Можем да видим един примерен цикличен код, който се поражда от полинома $x^3+x+1$, и има кодови думи с дължина 7 бита. \[
	G =
	\begin{bmatrix}
		1 & 1 & 0 & 1 & 0 & 0 & 0 \\
		0 & 1 & 1 & 0 & 1 & 0 & 0 \\
		0 & 0 & 1 & 1 & 0 & 1 & 0 \\
		0 & 0 & 0 & 1 & 1 & 0 & 1
	\end{bmatrix}
	\]
	\par Ха! Изненада! Това отново е $(7,4)$ кодът на Хеминг! \smiley
\end{frame}
\begin{frame}[allowframebreaks]
	\par Сега можем да посочим как работи кодирането на съобщение, използвайки цикличен код.
	\par Нека имаме $\mathcal{C}=\langle g \rangle$. Входното съобщение представяме чрез \textit{информационен полином} \[
	i(x) = i_0+\cdots+i_{k-1}x^{k-1}
	\]
	\par Имаме два подхода на кодиране, определени от това дали съобщението е част от получената кодова дума, или е ,,разбъркано''. Първият се нарича систематичен и именно него ще обясним тук. В него информационната последователност образува старшите членове на кодовата дума, т.е. \[
	c(x) = x^{n-k}i(x)+t(x)
	\]
	\framebreak
	\par Знаейки, че $g(x)\;\mid\;c(x)$, можем да използваме теоремата на Евклид - \[
		x^{n-k}i(x) = g(x)q(x)+r(x)
	\]
	и тогава \[
		c(x)=x^{n-k}i(x)+t(x)=g(x)q(x)+(r(x)+t(x))
	\]
	където $r(x)+t(x)$ е от степен по-малка от $n-k$ и се дели на $g(x)$, откъдето $r(x)=-t(x)$.
\end{frame}
\begin{frame}
	\egmarker
	\par Нека разгледаме един пример. Отново ще разгледаме познатия $(7,4)$ код на Хеминг. За него имаме, че $\mathcal{C}=\langle g \rangle$ при $g(x)=x^3+x+1$. Да вземем например съобщението $1001$. На него съпоставяме информационен полином \[
		i(x)=1+0x^1+0x^2+1x^3=x^3+1
	\]
	\par Кодовата дума получаваме като \[
		c(x)=x^3i(x)+t(x)=x^6+x^4+x^3 + t(x)
	\]
	\par Търсим $t(x)$, разделяйки $x^3i(x)$ на $g(x)$, т.е. $x^6+x^4+x^3$ на $x^3+x+1$. Получаваме $q(x)=x^3$ и $r(x)=0$.
\end{frame}

\section{Какво е код на Рид-Соломон?}
\begin{frame}
\end{frame}

\section{Как се използват Рид-Соломон кодовете?}
\begin{frame}
\end{frame}

\section{Какви приложения имат Рид-Соломон кодовете?}
\begin{frame}
\end{frame}

\begin{frame}[plain]
\centering
\Large{\textbf{Благодаря за вниманието!}}
\end{frame}

\begin{frame}[plain]
    \section{Литература}
\end{frame}

\begin{frame}[noframenumbering,plain,allowframebreaks]
\printbibliography[heading=none]
\end{frame}

\end{document}

